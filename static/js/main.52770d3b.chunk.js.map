{"version":3,"sources":["Cell.tsx","checkIfFieldInArray.ts","Field.tsx","useGetPressedKey.ts","SwipeControls/SwipeContext.ts","SwipeControls/useGetSwipedDirection.ts","directionalHooks.ts","useRenderCircle.ts","Controls.tsx","Game.tsx","SwipeControls/SwipeProvider.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Cell","type","className","checkIfFieldInArray","field","array","some","el","Boolean","x","y","Field","fieldWidth","fieldHeight","snake","food","style","gridTemplateColumns","maxWidth","R","map","index","isSnake","isFood","useGetPressedKey","useState","activeKeyCode","setActiveKeyCode","downHandler","code","upHandler","useEffect","window","addEventListener","removeEventListener","SwipeDirectionContext","React","createContext","useGetSwipedDirection","useContext","SwipeContext","keys","directions","useGetLastDirection","pressedDirection","pressedKey","find","includes","swipedDirection","usePressedGetDirection","direction","setDirection","useRenderCircle","fps","on","renderNow","setRenderNow","setTimeout","gameSizes","Controls","gameState","startGame","score","setFieldSize","onClick","initialGameSettings","initialSnake","initialSpeed","initialDirection","maxSpeed","speedIncrement","getOffsetFromDirection","generateFood","numberOfFields","numberOfEmptyFields","length","snakeFields","randomNumber","filter","a","b","min","max","Math","floor","random","getRandomNumber","App","gameSettings","setGameSettings","setSnake","lastPressedDirection","resetLastPressedDirection","setGameState","setFood","speed","setSpeed","currentHead","newDirection","secondDirection","pressedOffset","offset","getCorrectDirection","newHead","noCollisions","checkCollisions","foodEaten","newSnake","slice","size","Up","Down","Left","Right","SwipeProvider","children","handlers","useSwipeable","onSwiping","eventData","dir","onSwiped","console","log","Provider","value","Game","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.52770d3b.chunk.js","sourcesContent":["import React from 'react';\n\ninterface CellProp extends JSX.IntrinsicAttributes {\n  type: 'snake' | 'food' | 'empty';\n}\n\nconst Cell = ({ type }: CellProp): JSX.Element => {\n  return <div className={`field ${type}`} />;\n};\n\nexport default Cell;\n","import { Coordinates } from './types';\n\nconst checkIfFieldInArray = (field: Coordinates, array: Coordinates[]): boolean =>\n  array.some((el) => Boolean(el.x === field.x && el.y === field.y));\n\nexport default checkIfFieldInArray;\n","import React from 'react';\nimport * as R from 'ramda';\nimport Cell from './Cell';\nimport { Snake, Coordinates } from './types';\nimport checkIfFieldInArray from './checkIfFieldInArray';\n\ninterface FieldProp {\n  fieldWidth: number;\n  fieldHeight: number;\n  snake: Snake;\n  food: Coordinates | null;\n}\n\nconst Field = ({ fieldWidth, fieldHeight, snake, food }: FieldProp): JSX.Element => {\n  return (\n    <div\n      className=\"wrapper\"\n      style={{ gridTemplateColumns: `repeat(${fieldWidth}, 1fr)`, maxWidth: fieldWidth * 30 }}\n    >\n      {R.range(0, fieldWidth * fieldHeight).map((index) => {\n        const y = (index - (index % fieldWidth)) / fieldWidth;\n        const x = index % fieldHeight;\n        const coordinates = { x, y };\n        const isSnake = checkIfFieldInArray(coordinates, snake);\n        const isFood = food && food.x === x && food.y === y;\n        const type = isSnake ? 'snake' : isFood ? 'food' : 'empty';\n        return <Cell key={index} type={type} />;\n      })}\n    </div>\n  );\n};\n\nexport default Field;\n","import { useEffect, useState } from 'react';\n\nfunction hasWindow(): boolean {\n  return typeof window === 'object';\n}\n\nexport default function useGetPressedKey(): string | null {\n  const [activeKeyCode, setActiveKeyCode] = useState<string | null>(null);\n\n  const downHandler = ({ code }: KeyboardEvent) => {\n    if (code !== activeKeyCode) {\n      setActiveKeyCode(code);\n    }\n  };\n\n  const upHandler = ({ code }: KeyboardEvent) => {\n    if (code === activeKeyCode) {\n      setActiveKeyCode(null);\n    }\n  };\n\n  useEffect(() => {\n    if (!hasWindow()) {\n      return;\n    }\n\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  }, [downHandler, upHandler]);\n\n  return activeKeyCode;\n}\n","import React from 'react';\nimport { Direction } from '../types';\n\nconst SwipeDirectionContext = React.createContext<Direction | null>(null);\n\nexport default SwipeDirectionContext;\n","import { useContext } from 'react';\nimport SwipeContext from './SwipeContext';\nimport { Direction } from '../types';\n\nconst useGetSwipedDirection = (): Direction | null => {\n  return useContext(SwipeContext);\n};\n\nexport default useGetSwipedDirection;\n","import { useEffect, useState } from 'react';\nimport useGetPressedKey from './useGetPressedKey';\nimport useGetSwipedDirection from './SwipeControls/useGetSwipedDirection';\nimport { Direction } from './types';\n\nconst keys: { [key in Direction]: string[] } = {\n  '-y': ['KeyW', 'ArrowUp'],\n  '+y': ['KeyS', 'ArrowDown'],\n  '-x': ['KeyA', 'ArrowLeft'],\n  '+x': ['KeyD', 'ArrowRight'],\n};\n\nconst directions: Direction[] = ['-y', '+y', '-x', '+x'];\n\nexport const usePressedGetDirection = (): Direction | null => {\n  const pressedKey = useGetPressedKey();\n  const pressedDirection =\n    (pressedKey && directions.find((el) => keys[el].includes(pressedKey))) || null;\n  const swipedDirection = useGetSwipedDirection();\n  return pressedDirection || swipedDirection || null;\n};\n\nexport const useGetLastDirection = (): [Direction | null, () => void] => {\n  const pressedDirection = usePressedGetDirection();\n  const [direction, setDirection] = useState<Direction | null>(null);\n  useEffect(() => {\n    if (pressedDirection) {\n      setDirection(pressedDirection);\n    }\n  }, [direction, pressedDirection]);\n\n  const resetLastPressedDirection = () => setDirection(null);\n\n  return [direction, resetLastPressedDirection];\n};\n","import { useState, useEffect } from 'react';\n\nconst useRenderCircle = ({ fps, on }: { fps: number; on: boolean }): boolean => {\n  const [renderNow, setRenderNow] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (on) {\n      setRenderNow(true);\n    } else {\n      setTimeout(() => {\n        setRenderNow(false);\n      }, 1001 / fps);\n    }\n  }, [on]);\n\n  useEffect(() => {\n    if (renderNow && on) {\n      setRenderNow(false);\n      setTimeout(() => {\n        setRenderNow(true);\n      }, 1000 / fps);\n    }\n  }, [fps, on, renderNow]);\n  return renderNow && on;\n};\n\nexport default useRenderCircle;\n","import React from 'react';\nimport { GameStates } from './types';\n\ninterface ControlsProps {\n  gameState: GameStates;\n  startGame: () => void;\n  score: number;\n  setFieldSize: (size: number) => void;\n}\n\nconst gameSizes: number[] = [10, 15, 20];\n\nconst Controls = ({ gameState, startGame, score, setFieldSize }: ControlsProps): JSX.Element => {\n  return (\n    <div className=\"controls\">\n      {gameState !== 'ready' && <p className=\"text\">score: {score}</p>}\n      {gameState === 'ready' && <button onClick={startGame}>Start game</button>}\n      {gameState !== 'running' && (\n        <div className=\"select-filed-size-wrapper\">\n          {gameSizes.map((el) => (\n            <button className=\"size-button\" key={el} onClick={() => setFieldSize(el)}>\n              {el}\n            </button>\n          ))}\n        </div>\n      )}\n      {gameState === 'lost' && (\n        <>\n          <p className=\"text\">You lost</p>\n          <button onClick={startGame}>Start over</button>\n        </>\n      )}\n    </div>\n  );\n};\n\nexport default Controls;\n","import React, { useState, useEffect } from 'react';\nimport * as R from 'ramda';\nimport './App.css';\nimport Field from './Field';\nimport { Snake, Direction, GameStates, Coordinates, GameSettings } from './types';\nimport { useGetLastDirection } from './directionalHooks';\nimport useRenderCircle from './useRenderCircle';\nimport Controls from './Controls';\nimport checkIfFieldInArray from './checkIfFieldInArray';\n\nconst initialGameSettings: GameSettings = {\n  fieldWidth: 15,\n  fieldHeight: 15,\n  initialSnake: [\n    { x: 1, y: 0 },\n    { x: 0, y: 0 },\n  ],\n  initialSpeed: 4,\n  initialDirection: '+x',\n  maxSpeed: 15,\n  speedIncrement: 0.25,\n};\n\nconst getOffsetFromDirection = (direction: Direction | null): Coordinates => {\n  const x = direction === '+x' ? 1 : direction === '-x' ? -1 : 0;\n  const y = direction === '+y' ? 1 : direction === '-y' ? -1 : 0;\n  return { x, y };\n};\n\nconst getCorrectDirection = (\n  direction: Direction,\n  secondDirection: Direction | null,\n): Direction => {\n  const pressedOffset = getOffsetFromDirection(secondDirection);\n  const offset = getOffsetFromDirection(direction);\n\n  const directionIsInvalid =\n    (pressedOffset.x && pressedOffset.x === -offset.x) ||\n    (pressedOffset.y && pressedOffset.y === -offset.y);\n\n  if (!directionIsInvalid && secondDirection) {\n    return secondDirection;\n  }\n  return direction;\n};\n\nconst checkCollisions = (\n  newHead: Coordinates,\n  snake: Snake,\n  fieldWidth: number,\n  fieldHeight: number,\n): boolean =>\n  !(\n    newHead.x >= fieldWidth ||\n    newHead.x < 0 ||\n    newHead.y >= fieldHeight ||\n    newHead.y < 0 ||\n    checkIfFieldInArray(newHead, snake)\n  );\n\nconst generateFood = (snake: Snake, fieldWidth: number, fieldHeight: number): Coordinates => {\n  const numberOfFields = fieldWidth * fieldHeight;\n  const getRandomNumber = (a: number, b: number): number => {\n    const min = a > b ? b : a;\n    const max = a > b ? a : b;\n    return Math.floor(Math.random() * (max - min) + min);\n  };\n\n  const numberOfEmptyFields = numberOfFields - snake.length;\n\n  const snakeFields: number[] = snake.map((el) => el.x + el.y * fieldHeight);\n\n  const emptyFields = R.range(0, numberOfFields).filter((el) => !snakeFields.includes(el));\n\n  const randomNumberIndex = getRandomNumber(0, numberOfEmptyFields);\n\n  const randomNumber = emptyFields[randomNumberIndex];\n\n  return {\n    x: randomNumber % fieldHeight,\n    y: (randomNumber - (randomNumber % fieldWidth)) / fieldWidth,\n  };\n};\n\nconst App: React.FC = () => {\n  const [gameSettings, setGameSettings] = useState<GameSettings>(initialGameSettings);\n  const [snake, setSnake] = useState<Snake>([]);\n  const [direction, setDirection] = useState<Direction>(initialGameSettings.initialDirection);\n  const [lastPressedDirection, resetLastPressedDirection] = useGetLastDirection();\n  const [gameState, setGameState] = useState<GameStates>('ready');\n  const [food, setFood] = useState<Coordinates | null>(null);\n  const [speed, setSpeed] = useState(initialGameSettings.initialSpeed);\n\n  const setFieldSize = (size: number) => {\n    setGameSettings({ ...gameSettings, fieldHeight: size, fieldWidth: size });\n  };\n\n  useEffect(() => {\n    if (gameState === 'running') {\n      const { fieldWidth, fieldHeight } = initialGameSettings;\n      setFood(generateFood(snake, fieldWidth, fieldHeight));\n    }\n  }, [gameState, setFood]);\n\n  const renderNow = useRenderCircle({ fps: speed, on: gameState === 'running' });\n\n  const startGame = () => {\n    resetLastPressedDirection();\n    setSnake(gameSettings.initialSnake);\n    setDirection(gameSettings.initialDirection);\n    setSpeed(gameSettings.initialSpeed);\n    setGameState('running');\n  };\n\n  useEffect(() => {\n    if (renderNow && snake.length) {\n      const currentHead = snake[0];\n\n      const newDirection = getCorrectDirection(direction, lastPressedDirection);\n\n      const offset = getOffsetFromDirection(newDirection);\n\n      setDirection(newDirection);\n\n      resetLastPressedDirection();\n\n      const newHead: Coordinates = { x: currentHead.x + offset.x, y: currentHead.y + offset.y };\n      const noCollisions = checkCollisions(\n        newHead,\n        snake,\n        gameSettings.fieldWidth,\n        gameSettings.fieldHeight,\n      );\n\n      if (noCollisions) {\n        const foodEaten = food && newHead.x === food.x && newHead.y === food.y;\n\n        const newSnake: Snake = [newHead, ...(foodEaten ? snake : snake.slice(0, -1))];\n        if (foodEaten) {\n          if (speed < gameSettings.maxSpeed) setSpeed(speed + gameSettings.speedIncrement);\n\n          setFood(generateFood(newSnake, gameSettings.fieldWidth, gameSettings.fieldHeight));\n        }\n\n        setSnake(newSnake);\n      } else {\n        setGameState('lost');\n      }\n    }\n  }, [renderNow, snake, setSnake, direction, setDirection, lastPressedDirection]);\n\n  return (\n    <div className=\"gameWrapper\">\n      <Controls\n        gameState={gameState}\n        startGame={startGame}\n        score={snake.length - gameSettings.initialSnake.length}\n        setFieldSize={setFieldSize}\n      />\n      <Field\n        fieldWidth={gameSettings.fieldWidth}\n        fieldHeight={gameSettings.fieldHeight}\n        snake={snake}\n        food={food}\n      />\n    </div>\n  );\n};\n\nexport default App;\n","import React, { useState } from 'react';\nimport { useSwipeable, SwipeDirections } from 'react-swipeable';\nimport SwipeContext from './SwipeContext';\nimport { Direction } from '../types';\n\nconst keys: { [key in SwipeDirections]: Direction } = {\n  Up: '-y',\n  Down: '+y',\n  Left: '-x',\n  Right: '+x',\n};\n\nconst SwipeProvider: React.FC = ({ children }) => {\n  const [direction, setDirection] = useState<Direction | null>(null);\n  const handlers = useSwipeable({\n    onSwiping: (eventData) => {\n      const { dir } = eventData;\n      setDirection(keys[dir]);\n    },\n    onSwiped: () => setDirection(null),\n  });\n\n  console.log('direction', direction);\n\n  return (\n    <SwipeContext.Provider value={direction}>\n      <div className=\"swipe-container\" {...handlers}>\n        {children}\n      </div>\n    </SwipeContext.Provider>\n  );\n};\n\nexport default SwipeProvider;\n","import React from 'react';\nimport './App.css';\nimport Game from './Game';\nimport SwipeProvider from './SwipeControls/SwipeProvider';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <SwipeProvider>\n        <div className=\"App-header\">\n          <Game />\n        </div>\n      </SwipeProvider>\n    </div>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}